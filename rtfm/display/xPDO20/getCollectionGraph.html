<h2>
<a name="getCollectionGraph-Overview" id="getCollectionGraph-Overview"></a>Overview
</h2>

<p>
getCollectionGraph allows you to automatically load up related objects by specifying a JSON style hash to its second argument (in other words, it automatically joins a table on its related tables). It's possible to nest the JSON hash so you also retrieve the related objects of the related objects, for example:
</p>

<pre class="brush: php">
    
&lt;?php
$out = false;
$xpdo-&gt;setPackage('sw_zipCode', MODX_BASE_PATH.'wsw/model/', 'sw_');
$collection= $xpdo-&gt;getCollectionGraph('Zip', '{"TZ":{},"ST":{},"CT":{}}', $lookupZip);
foreach ($collection as $obj)
{
    if (is_object($obj))
    {
        $out = $obj-&gt;toArray();                      // 'Zip'
        $out[timezone] = $obj-&gt;TZ-&gt;get('tzname');
        $out[state] = $obj-&gt;ST-&gt;get('statename');
        $out[county] = $obj-&gt;CT-&gt;get('countyname');        
    }
}
return $out;
?&gt;

    
</pre>
<div class="note">
Note that when you are using $xpdo-&gt;newQuery() to filter the results and have multiple field names which are the same, for example an "id" field, in one or more of the different classes you join, xPDO will fail to return any result. Simply prefix your fieldname with the classname in that case, for example myClassName.id
</div>

<h3>
<a name="getCollectionGraph-SnippetCall" id="getCollectionGraph-SnippetCall"></a>Snippet Call
</h3>

<pre class="brush: php">
    
Array
(
    [id] =&gt; 32117
    [city] =&gt; Daytona Beach
    [areacode] =&gt; 386
    [lat] =&gt; 29.233
    [lon] =&gt; -81.0479
    [sw_county_id] =&gt; 1800
    [sw_states_id] =&gt; 15
    [sw_timezones_id] =&gt; 4
    [timezone] =&gt; Eastern
    [state] =&gt; Florida
    [county] =&gt; Volusia
)


    
</pre>
<h3>
<a name="getCollectionGraph-EquivalentMySQL" id="getCollectionGraph-EquivalentMySQL"></a>Equivalent MySQL
</h3>

<pre class="brush: php">
    
?
&lt;model package="sw_zipCode" baseClass="xPDOObject" platform="mysql" defaultEngine="MyISAM"&gt;
?
&lt;object klass="class="City" table="city" extends="xPDOSimpleObject"&gt;
&lt;field key="cityname" dbtype="varchar" precision="50" phptype="string" null="false"/&gt;
&lt;/object&gt;
?
&lt;object klass="Cityzip" table="cityzip" extends="xPDOSimpleObject"&gt;
&lt;field key="city" dbtype="int" precision="10" phptype="integer" null="false"/&gt;
&lt;field key="zip" dbtype="int" precision="5" phptype="integer" null="false"/&gt;
&lt;/object&gt;
?
&lt;object klass="County" table="county" extends="xPDOSimpleObject"&gt;
&lt;field key="countyname" dbtype="varchar" precision="35" phptype="string" null="true" index="index"/&gt;
&lt;/object&gt;
?
&lt;object klass="States" table="states" extends="xPDOSimpleObject"&gt;
&lt;field key="statename" dbtype="varchar" precision="40" phptype="string" null="false" index="index"/&gt;
&lt;field key="abbrv" dbtype="char" precision="2" phptype="string" null="false"/&gt;
&lt;/object&gt;
?
&lt;object klass="Timezones" table="timezones" extends="xPDOSimpleObject"&gt;
&lt;field key="tzname" dbtype="varchar" precision="20" phptype="string" null="true" index="index"/&gt;
&lt;/object&gt;
?
&lt;object klass="Zip" table="zips" extends="xPDOSimpleObject"&gt;
&lt;field key="city" dbtype="varchar" precision="50" phptype="string" null="true"/&gt;
&lt;field key="areacode" dbtype="int" precision="3" phptype="integer" null="true"/&gt;
&lt;field key="lat" dbtype="float" phptype="float" null="true"/&gt;
&lt;field key="lon" dbtype="float" phptype="float" null="true"/&gt;
&lt;field key="sw_county_id" dbtype="int" precision="4" phptype="integer" null="false" index="pk"/&gt;
&lt;field key="sw_states_id" dbtype="int" precision="2" phptype="integer" null="false" index="pk"/&gt;
&lt;field key="sw_timezones_id" dbtype="int" precision="2" phptype="integer" null="false" index="pk"/&gt;
&lt;aggregate alias="TZ" klass="Timezones" local="tz_id" foreign="id" cardinality="one" owner="foreign" /&gt;    
&lt;aggregate alias="ST" klass="County" local="sw_county_id" foreign="id" cardinality="one" owner="foreign" /&gt;
&lt;aggregate alias="CT" klass="States" local="sw_states_id" foreign="id" cardinality="one" owner="foreign" /&gt;
&lt;/object&gt;
&lt;/model&gt;

    
</pre>
<h2>
<a name="getCollectionGraph-AnotherExample" id="getCollectionGraph-AnotherExample"></a>Another Example
</h2>

<p>
Another relation example that is common is joining MODX pages with their Template Variable values. Sometimes this does not work as expected since values are stored differently than you might expect. But here's a walk-through.
</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">
$pages = $modx-&gt;getCollectionGraph('modResource', '{<span class="code-quote">"TemplateVarResources"</span>:{}}', array('parent'=&gt;12));

foreach ($pages as $p) {
        foreach ($p-&gt;TemplateVarResources as $tv) {
                <span class="code-comment">// Do stuff here with the TV
</span>         $tv_array = $tv-&gt;toArray();
                $tv-&gt;get('value');
        }
}
</pre>
</div>
</div>

<h2>
<a name="getCollectionGraph-Comments" id="getCollectionGraph-Comments"></a>Comments
</h2>

<ol>
<li>Obtain a connection via <a href="display/XPDO10/The+xPDO+Constructor" title="The xPDO Constructor">the xPDO Constructor</a> including&nbsp; <a href="display/xPDO20/Hydrating+Fields" title="Hydrating Fields">Hydrating Fields</a>
</li>

<li>Viewing the package name in the schema we set (or apply) the package to our connection, taking note of the prefix our tables are using in the database
</li>

<li>&nbsp;Using 'Zip' as our "view" we look at the relationships directly defined in the Zip object, in our schema, and access those via the aliases given there
</li>
</ol>

<h2>
<a name="getCollectionGraph-AdditionalNotes%3A"></a>Additional Notes:
</h2>

<p>
Everything is about the schema definition. A poorly thought out and developed schema may very well lead to many hours of frustration.
</p>

<p>
If you are having trouble with xPDO, you have two main avenues of troubleshooting:
</p>

<ol>
<li>First and foremost -- the schema is not correct.&nbsp; Re thinking it from the bottom relations up, and through each relationship may help us "see" where we may be missing it.
</li>

<li>Not understanding what we are seeing is another huge issue.
<ol>
<li>Understand the point of your schema.&nbsp; If your schema will eventually instantiate an object representing a single entity (such as a user) your base relationships should be ($this-&gt;user) 1:&nbsp; 1 or many on the other side.
</li>

<li>A relationship tied to a many-to-many relation (as in the relations between users and groups) will probably need a for each loop to filter through the sub relation.
</li>

<li>Aggregate relations should typically be singular.&nbsp; Removing them does nothing to the related data
</li>

<li>Composite relations should typically be plural.&nbsp; Removing them also removes each of the related child relations.
</li>

<li>Don't be afraid to use regular language in your schema. Instead of Cityzip, in the schema above, Cityhaszips might be a bit clearer in thinking through your schema
</li>

<li>Don't use the same class name in multiple places in the schema.&nbsp; Not only will it bring&nbsp; confusion while coding, I suspect it also confuses xPDO.&nbsp; If for no other reason -- its just bad form.
</li>

<li>xPDO is fast, very fast.&nbsp; If your queries are taking to long, go back to the schema and follow the indexes.
</li>

<li>xPDO likes primary keys, so build your relations around primary keys when ever possible -- if not always.
</li>

<li>In case you missed it '{"TZ":{},"ST":{},"CT":{}}' is JSON formatted.
</li>
</ol>
</li>
</ol>