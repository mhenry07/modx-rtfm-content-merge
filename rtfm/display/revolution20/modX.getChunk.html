<h2>
<a name="modX.getChunk-modX%3A%3AgetChunk"></a>modX::getChunk
</h2>

<p>
Processes and returns the output from an HTML chunk by name.
</p>

<p>
<b>getChunk</b> actually sets the properties you pass (and that are picked up from default properties and/or a property set) as placeholders (preserving any with the same key and restoring those after processing is complete) and allows the modChunk class to process() them (along with any other tags, filters, etc.).
</p>

<div class="info">
<b>getChunk</b> will execute the MODX parser, so you can use output filters and the $properties array can be multi-dimenstional (i.e. more than just simple key/value pairs). If this is more horsepower than you need, use <a href="display/revolution20/modX.parseChunk" title="modX.parseChunk">modX.parseChunk</a> instead.
</div>

<h2>
<a name="modX.getChunk-Syntax" id="modX.getChunk-Syntax"></a>Syntax
</h2>

<p>
API Doc: <a href="http://api.modx.com/revolution/2.2/db_core_model_modx_modx.class.html#%5CmodX::getChunk()" class="external-link" rel="nofollow">http://api.modx.com/revolution/2.2/db_core_model_modx_modx.class.html#%5CmodX::getChunk()</a>
</p>

<pre class="brush: php">
    
$properties = array('key' =&gt; 'value');

    
</pre>
<p>
Which would cause the [[+key]] placeholders to be replaced by the 'value'.
</p>

<p>
However, <b>$properties</b> can also be a more deeply nested array such as the kind that might be returned from certain getObject or getCollection queries, e.g.
</p>

<pre class="brush: php">
    &lt;p&gt;Welcome [[+name]]!&lt;/p&gt;
    
</pre>
<p>
We'll put this in our Snippet:
</p>

<pre class="brush: php">
    &lt;p&gt;Welcome John!&lt;/p&gt;
    
</pre>
<h3>
<a name="modX.getChunk-Nested%24properties"></a>Nested $properties
</h3>

<p>
In our Chunk:
</p>

<pre class="brush: php">
    
$output = $modx-&gt;getChunk('UserLink',array(
   'user' =&gt; array('id' =&gt; 123)
);
return $output;

    
</pre>
<h3>
<a name="modX.getChunk-UsedinaSnippet" id="modX.getChunk-UsedinaSnippet"></a>Used in a Snippet
</h3>

<p>
Often, MODX Chunks are used as <a href="http://php.net/manual/en/function.sprintf.php" class="external-link" rel="nofollow">formatting string</a> by Snippets. To that end, you can make good use of xPDO's <a href="display/xPDO20/toArray" title="toArray">toArray()</a> method.
</p>

<p>
Imagine a Chunk named <b>single_user</b>:
</p>

<pre class="brush: php">
    
$userlist = $modx-&gt;getCollection('modUser');

$output = '';
foreach ($userlist as $user) {
    $output .= $modx-&gt;getChunk('single_user', $user-&gt;toArray() );
}

return $output;

    
</pre>
<h3>
<a name="modX.getChunk-ParsingaString" id="modX.getChunk-ParsingaString"></a>Parsing a String
</h3>

<p>
Sometimes you need to parse a string using the MODX parser â€“ this does not use getChunk, but it is related. Using the MODX parser is a bit slower than using a simple str_replace function, but it does let you use complex placeholders (e.g. to include another Chunk) and output filters etc. The trick is to create a temporary Chunk object, then run the <b>process</b> method on it.
</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">
<span class="code-comment">// The formatting <span class="code-object">String</span>
</span>$tpl = 'Hello, my name is [[+name]]';

<span class="code-comment">// Properties
</span>$props = array('name' =&gt; 'Bob');

<span class="code-comment">// Create the temporary chunk
</span>$uniqid = uniqid();
$chunk = $modx-&gt;newObject('modChunk', array('name' =&gt; <span class="code-quote">"{tmp}-{$uniqid}"</span>));
$chunk-&gt;setCacheable(<span class="code-keyword">false</span>);

$output = $chunk-&gt;process($props, $tpl);
</pre>
</div>
</div>

<h2>
<a name="modX.getChunk-SeeAlso" id="modX.getChunk-SeeAlso"></a>See Also
</h2>

<ul>
<li>
<a href="display/revolution20/Chunks" title="Chunks">Chunks</a>
</li>

<li>
<a href="display/revolution20/modX.parseChunk" title="modX.parseChunk">modX.parseChunk</a>
</li>
</ul>