<p>
//
</p>

<div>
<ul>
<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-WhatismodRegistry%3F">What is modRegistry?</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-ChoosingamodRegisterimplementation">Choosing a modRegister implementation</a>
<ul>
<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-modFileRegister">modFileRegister</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-modDbRegister">modDbRegister</a>
</li>
</ul>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-UsingtheRegistryAPI">Using the Registry API</a>
<ul>
<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-Connecting">Connecting</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-Subscribing">Subscribing</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-SendingMessages">Sending Messages</a>
<ul>
<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-SendinganArrayofSequencedMessages">Sending an Array of Sequenced Messages</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-SendinganArrayofNamedMessages">Sending an Array of Named Messages</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-SendingaSingleMessage">Sending a Single Message</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-OptionsforSendingMessages">Options for Sending Messages</a>
<ul>
<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-delay">delay</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-ttl">ttl</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-kill">kill</a>
</li>
</ul>
</li>
</ul>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-ReadingMessages">Reading Messages</a>
<ul>
<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-PollingforNewMessagesinaTopic">Polling for New Messages in a Topic</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-OptionsforReadingMessages">Options for Reading Messages</a>
<ul>
<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-polllimit">poll_limit</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-pollinterval">poll_interval</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-timelimit">time_limit</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-msglimit">msg_limit</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-removeread">remove_read</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-includekeys%28MODX2.2only%29">include_keys <em>(MODX 2.2+ only)</em></a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-UsingtheRegistryProcessors">Using the Registry Processors</a>
<ul>
<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-SendingMessages">Sending Messages</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-ReadingMessages">Reading Messages</a>
</li>
</ul>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-Examples">Examples</a>
<ul>
<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-AlternativetoSessionStorage">Alternative to Session Storage</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-CapturingLogMessages">Capturing Log Messages</a>
</li>

<li>
<a href="revolution/2.x/developing-in-modx/advanced-development/modx-services/modregistry#modRegistry-RegisteringLoadBalancedWebNodesforRemoteCommands">Registering Load Balanced Web Nodes for Remote Commands</a>
</li>
</ul>
</li>
</ul>
</div>

<h2 id="modRegistry-WhatismodRegistry?">
What is modRegistry?
</h2>

<p>
The modRegistry service provided with the MODX Revolution Core is a simple message queue service that developers can make use of for a wide variety of purposes. It comes with a file and database modRegister implementation, and can be extended to work with custom or external message queue implementations.
</p>

<p>
The modRegistry service can connect to any number of unique registers. Within each register, specific topics are subscribed to and messages can then be sent or read from the topic.
</p>

<h2 id="modRegistry-ChoosingamodRegisterimplementation">
Choosing a modRegister implementation
</h2>

<p>
MODX ships with two simple modRegister implementations. One is file-based and one uses database tables for storage. Each has benefits and limitations that you should consider before determining which one to use for a specific purpose.
</p>

<h3 id="modRegistry-modFileRegister">
modFileRegister
</h3>

<p>
This file-based register reads and writes messages, by default, to files under the <code>registry/</code> folder in the MODX <code>cache_path</code> location. This is great for single-server deployments that do not have high-traffic requirements where writing and reading to the the same topics might occur simultaneously from multiple client requests.
</p>

<p>
Here is how you would add a specific file-based register named <em>food</em>:
</p>

<pre class="brush: php">
&lt;?php
$modx-&gt;getService('registry', 'registry.modRegistry');
$modx-&gt;registry-&gt;addRegister('food', 'registry.modFileRegister', array('directory' =&gt; 'food'));
</pre>
<div class="warning">
<strong>Be Careful!</strong>
<br />
Clearing the cache manually by deleting all files and folders under <code>core/cache/</code> will delete any existing modFileRegister messages as well.
</div>

<h3 id="modRegistry-modDbRegister">
modDbRegister
</h3>

<p>
When reading and writing is expected to reach higher volumes, or you need messages shared across a load-balanced environment with multiple web server nodes, you would want to choose the database-powered modRegister implementation.
</p>

<p>
Here is how you would add a specific database register named <em>food</em>:
</p>

<pre class="brush: php">
&lt;?php
$modx-&gt;getService('registry', 'registry.modRegistry');
$modx-&gt;registry-&gt;addRegister('food', 'registry.modDbRegister', array('directory' =&gt; 'food'));
</pre>
<h2 id="modRegistry-UsingtheRegistryAPI">
Using the Registry API
</h2>

<p>
The modRegistry service provides a very simple API for working with Registers, subscribing to topics, and sending/reading messages within them.
</p>

<h3 id="modRegistry-Connecting">
Connecting
</h3>

<p>
Once you have obtained the modRegistry and initialized a modRegister implementation of your choice, you can now attempt to make a connection to your queue. Here is how you would connect to the <em>food</em> register we added in the examples above.
</p>

<pre class="brush: php">
&lt;?php
$connected = $modx-&gt;registry-&gt;food-&gt;connect();
</pre>
<p>
If there is any problem connecting to the register instance, the return value will be <code>false</code>.
</p>

<h3 id="modRegistry-Subscribing">
Subscribing
</h3>

<p>
Once you make a successful connection, it is time to subscribe to a topic for relevant messages to be sent or read. Let's subscribe to a nice topic about <em>beer</em> in our <em>food</em> register:
</p>

<pre class="brush: php">
&lt;?php
$modx-&gt;registry-&gt;food-&gt;subscribe("/beer/");
</pre>
<p>
This adds the topic "/beer/" to your subscriptions and sets it as the current topic. Topics are similar to relative URI's. If you specify a slash at the beginning, you are subscribing to a topic from the root of the register. No initial slash would indicate you want to subscribe to a sub-topic of the current topic. Once subscribed to at least one topic, you are free to send and read messages from them at will.
</p>

<h3 id="modRegistry-SendingMessages">
Sending Messages
</h3>

<p>
You can send messages to a topic in multiple ways. They can be sent as an array of sequenced messages (ordered by time sent and the array keys provided), named messages ordered by key (by providing associative array keys), or as a single message that automatically gets a time stamp.
</p>

<h4 id="modRegistry-SendinganArrayofSequencedMessages">
Sending an Array of Sequenced Messages
</h4>

<p>
Let's say we wanted to send three messages that should be read in the same order as they were sent. We simply provide an array of those messages in the order to read them in:
</p>

<pre class="brush: php">
&lt;?php
$modx-&gt;registry-&gt;food-&gt;send("/beer/", array("beer1", "beer2", "beer3"));
</pre>
<h4 id="modRegistry-SendinganArrayofNamedMessages">
Sending an Array of Named Messages
</h4>

<p>
You can also provide an associative array to send messages with specific keys that will be read according to the order of the keys:
</p>

<pre class="brush: php">
&lt;?php
$modx-&gt;registry-&gt;food-&gt;send("/beer/", array("Heineken" =&gt; "not so good", "Pabst Blue Ribbon" =&gt; "rocks", "Molson Golden" =&gt; "ok for Canadian beer"));
</pre>
<p>
These messages will be read in ascending alphabetic order, or specifically by key.
</p>

<h4 id="modRegistry-SendingaSingleMessage">
Sending a Single Message
</h4>

<p>
Sometimes it is necessary to send a single message without a specific key. The MODX register will automatically provide a time-based key for the message so that it is read in a proper time-based order.
</p>

<pre class="brush: php">
&lt;?php
$modx-&gt;registry-&gt;food-&gt;send("/beer/", "It's Miller Time!", array('kill' =&gt; true));
</pre>
<div class="note">
The <em>kill</em> option tells message consumers to stop reading any further messages once a message with this option is read.
</div>

<h4 id="modRegistry-OptionsforSendingMessages">
Options for Sending Messages
</h4>

<h5 id="modRegistry-delay">
delay
</h5>

<p>
Only supported for time-based messages (no keys provided), this option specifies the number of seconds to delay the message before it can be read. The message is still sent immediately to the queue, but is not available for reading until the specified delay has expired.
</p>

<h5 id="modRegistry-ttl">
ttl
</h5>

<p>
The <em>time to live</em> option specifies how many seconds the message(s) remain valid in the queue. Once a message has outlived it's ttl, it will not be included in the messages returned by a <code>read()</code> operation.
</p>

<h5 id="modRegistry-kill">
kill
</h5>

<p>
If specified, when a message consumer reads a message with this option set, no further messages will be read from the queue, regardless of any other read options.
</p>

<h3 id="modRegistry-ReadingMessages">
Reading Messages
</h3>

<p>
You can also read messages from a topic in a variety of ways using options passed to the <code>read()</code> method.
</p>

<h4 id="modRegistry-PollingforNewMessagesinaTopic">
Polling for New Messages in a Topic
</h4>

<p>
The most common use of the registry is to look for up to x number of new messages in any subscribed topics. Here we are polling once for up to 5 new messages in the current topic, which is "/beer/":
</p>

<pre class="brush: php">
&lt;?php
$msgs = $modx-&gt;registry-&gt;food-&gt;read(array(
    'poll_limit' =&gt; 1,
    'msg_limit' =&gt; 5
));
</pre>
<p>
This returns an array of the messages sent to the queue in the order they are read, without the corresponding message keys, regardless if they were specified when sent.
</p>

<h4 id="modRegistry-OptionsforReadingMessages">
Options for Reading Messages
</h4>

<h5 id="modRegistry-polllimit">
poll_limit
</h5>

<p>
By default, a modRegister will attempt to poll for messages until the msg_limit, time_limit, or a message with the kill option is encountered. In most situations when using the modRegister in web requests, this is not desirable. Most cases will want to set this option to 1, so the read operation only checks the queue once for messages and moves on regardless if the msg_limit or time_limit is hit. This option is useful if you want to set up a simple PHP polling server that checks for messages and takes action based on them (e.g. in a cronjob).
</p>

<h5 id="modRegistry-pollinterval">
poll_interval
</h5>

<p>
A configurable delay to wait between polling for new messages, in seconds. Default is unlimited.
</p>

<h5 id="modRegistry-timelimit">
time_limit
</h5>

<p>
The maximum number of seconds to poll for new messages when multiple poll attempts are configured (i.e. poll_limit != 1).
</p>

<h5 id="modRegistry-msglimit">
msg_limit
</h5>

<p>
The maximum number of messages to read from the queue. The default is 5 messages.
</p>

<h5 id="modRegistry-removeread">
remove_read
</h5>

<p>
Indicates if the message should be removed when it is read.
</p>

<h5 id="modRegistry-includekeys(MODX2.2only)">
include_keys <em>(MODX 2.2+ only)</em>
</h5>

<p>
Indicates if the read operation should include the message keys. If not true, only the messages are returned in a simple, ordered array.
</p>

<h2 id="modRegistry-UsingtheRegistryProcessors">
Using the Registry Processors
</h2>

<p>
In addition to the raw API, MODX also provides connectors and processors for sending messages to and reading messages from a register topic. These can be easily utilized by components using the runProcessor method or by AJAX requests via the connectors.
</p>

<h3 id="modRegistry-SendingMessages">
Sending Messages
</h3>

<p>
There are several parameters that control the behavior of the <code>system/registry/register/send</code> processor, which is used to send a message or multiple messages to a specific register topic. These parameters can be passed to the runProcessor method as properties or passed to the processor via REQUEST variables from the connector.
</p>

<ul>
<li>
<strong>register</strong> <em>(required)</em> — The name of the register to send a message to.
</li>

<li>
<strong>topic</strong> <em>(required)</em> — The topic to send a message to within the specified register.
</li>

<li>
<strong>register_class</strong> <em>(optional)</em> — Specifies the modRegister implementation to use; default is <code>registry.modFileRegister</code>.
</li>

<li>
<strong>message</strong> <em>(optional)</em> — The message(s) to send to the register topic. In MODX 2.2+, multiple messages can be sent using <code>json</code> as the <strong>message_format</strong>.
</li>

<li>
<strong>message_key</strong> <em>(optional, MODX 2.2+)</em> — An optional message key that can be provided to send a named message to the topic. If empty, the message is given a sequenced timestamp as the key.
</li>

<li>
<strong>message_format</strong> <em>(optional, MODX 2.2+)</em> — Default is string, which just sends the message as a string. If this is set to <code>json</code>, the message is converted to PHP before being sent, allowing multiple or more complex messages to be sent.
</li>
</ul>

<h3 id="modRegistry-ReadingMessages">
Reading Messages
</h3>

<p>
Reading messages with the <code>system/registry/register/read</code> processor can also be accomplished via runProcessor or the connector. Following are the parameters for reading.
</p>

<ul>
<li>
<strong>register</strong> <em>(required)</em> — The name of the register to send a message to.
</li>

<li>
<strong>topic</strong> <em>(required)</em> — The topic to send a message to within the specified register.
</li>

<li>
<strong>register_class</strong> <em>(optional)</em> — Specifies the modRegister implementation to use; default is <code>registry.modFileRegister</code>.
</li>

<li>
<strong>format</strong> <em>(optional, MODX 2.2+)</em> — If specified as <code>json</code>, the messages are converted to JSON before being returned; esp. useful for AJAX requests. If specified as <code>html_log</code>, the messages are assumed to be xPDO/modX log messages and are formatted for HTML output; useful for modExt consoles. By default, the messages are returned as an array.
</li>

<li>
<strong>poll_limit</strong> <em>(optional)</em> — The number of times to poll for new messages before exiting; default is 1.
</li>

<li>
<strong>poll_interval</strong> <em>(optional)</em> — The number of seconds to delay each poll attempt for new messages before exiting; default is 1.
</li>

<li>
<strong>time_limit</strong> <em>(optional)</em> — The number of seconds to continue polling for new messages before exiting; default is 10.
</li>

<li>
<strong>message_limit</strong> <em>(optional)</em> — The maximum number of messages to return; default is 200.
</li>

<li>
<strong>remove_read</strong> <em>(optional)</em> — Indicates if returned messages should be removed from the queue; default is true.
</li>

<li>
<strong>include_keys</strong> <em>(optional, MODX 2.2+)</em> — Indicates if returned messages should include the message keys; default is false.
</li>

<li>
<strong>show_filename</strong> <em>(optional)</em> — Indicates if html_log formatted messages should include the filename; default is false.
</li>
</ul>

<h2 id="modRegistry-Examples">
Examples
</h2>

<h3 id="modRegistry-AlternativetoSessionStorage">
Alternative to Session Storage
</h3>

<p>
There might be times that session storage is not appropriate for persisting personalized information. In these cases, you could use a register topic to store the data and retrieve it, regardless of the user's session state. This might be useful for custom registration systems where unauthorized users are turned into authorized users and you need access to data stored before the new authorized user's session was started (i.e. they logged in).
</p>

<p>
You might write a named message into a topic for retrieval by key at a later time, as done in the Login Add-On for useractivation:
</p>

<pre class="brush: php">
&lt;?php
$modx-&gt;getService('registry', 'registry.modRegistry');
$modx-&gt;registry-&gt;addRegister('login', 'registry.modFileRegister', array('directory' =&gt; 'login'));
$modx-&gt;registry-&gt;login-&gt;connect();
$modx-&gt;registry-&gt;login-&gt;subscribe('/useractivation/');
$modx-&gt;registry-&gt;login-&gt;send('/useractivation/',array($user-&gt;get('username') =&gt; $pword),array(
    'ttl' =&gt; ($modx-&gt;getOption('activationttl',$scriptProperties,180)*60),
));
</pre>
<p>
And to retrieve the specific message later:
</p>

<pre class="brush: php">
&lt;?php
$modx-&gt;getService('registry', 'registry.modRegistry');
$modx-&gt;registry-&gt;addRegister('login','registry.modFileRegister');
$modx-&gt;registry-&gt;login-&gt;connect();
$modx-&gt;registry-&gt;login-&gt;subscribe('/useractivation/'.$user-&gt;get('username'));
$msgs = $modx-&gt;registry-&gt;login-&gt;read(array('poll_limit' =&gt; 1));
$password = reset($msgs);
</pre>
<h3 id="modRegistry-CapturingLogMessages">
Capturing Log Messages
</h3>

<p>
MODX supports specifying the logTarget as a modRegister instance. This allows you to capture all log messages a message queue where you can read them later to provide user feedback, audit views, etc.
</p>

<pre class="brush: php">
&lt;?php
$modx-&gt;getService('registry', 'registry.modRegistry');
$modx-&gt;registry-&gt;addRegister('logging', 'registry.modFileRegister', array('directory' =&gt; 'logging'));
$modx-&gt;registry-&gt;logging-&gt;connect();
$modx-&gt;registry-&gt;logging-&gt;subscribe($topic);

/* set the logTarget to the register instance */
$oldTarget = $modx-&gt;setLogTarget($modx-&gt;registry-&gt;logging);

/* code here that sends log messages */

/* set the old target back */
$modx-&gt;setLogTarget($oldTarget);
</pre>
<h3 id="modRegistry-RegisteringLoadBalancedWebNodesforRemoteCommands">
Registering Load Balanced Web Nodes for Remote Commands
</h3>

<p>
This example solution using modRegistry uses two plugins to help manage cache refresh operations across multiple web nodes, each using it's own local file cache.
</p>

<p>
The first, which is attached to OnWebPageComplete, registers each server instance for 20 minutes (this was designed for a cloud deployment that would launch and kill new server instances on demand, but you can remove the expiration time to avoid the overhead of writing those messages every 20 minutes) and then looks for any messages with the command 'clearCache' specified. The second, attached to the OnSiteRefresh event allows clearing the cache in the manager to register a 'clearCache' message with all of the remote server 'instances' that have been registered by the first plugin. You can take the idea and tailor it for your environment, but in our experience the best practice is to isolate one server instance for the manager (via subdomain configuration or similar) that is separate from your remote web nodes. This allows activity to take place on the manager instance in high volume, then changes only get pushed out when the Refresh site action is taken from the Admin menu.
</p>

<p>
Here is an example remotecommands plugin (NOTE this is for MODX 2.1, and 2.0 would be slightly different, using clearCache() instead of refresh()):
</p>

<pre class="brush: php">
&lt;?php
/* RemoteCommands plugin -- register with OnWebPageComplete event */
 
/* find any remote commands to execute from the master instance */
$instance = $_SERVER['SERVER_ADDR'];
if (!empty($instance) &amp;&amp; $modx-&gt;getService('registry', 'registry.modRegistry')) {
    $modx-&gt;registry-&gt;addRegister('remotes', 'registry.modDbRegister', array('directory' =&gt; 'remotes'));
    $modx-&gt;registry-&gt;remotes-&gt;connect();
 
    /* register this instance */
    $modx-&gt;registry-&gt;remotes-&gt;subscribe("/distrib/instances/");
    $modx-&gt;registry-&gt;remotes-&gt;send("/distrib/instances/", array($instance =&gt; true), array('expires' =&gt; time() + 1440));
 
    /* find any valid command messages for this instance and act on them */
    $modx-&gt;registry-&gt;remotes-&gt;subscribe("/distrib/commands/{$instance}/");
    $commands = $modx-&gt;registry-&gt;remotes-&gt;read(array('poll_limit' =&gt; 1, 'msg_limit' =&gt; 1));
    if (!empty($commands)) {
        $command = reset($commands);
        if (!empty($command)) {
             switch ($command) {
                 case 'clearCache':
                    $results= $modx-&gt;cacheManager-&gt;refresh();
                    break;
                 default:
                    break;
             }
        }
    }
}
</pre>
<p>
And here is an example sendclearcache plugin for registering a remote command message to each remote server instance:
</p>

<pre class="brush: php">
&lt;?php
/* SendClearCache plugin -- register with OnSiteRefresh event */
 
/* read instances and write clear cache msg to each command directory */
if ($modx-&gt;getService('registry', 'registry.modRegistry')) {
    $modx-&gt;registry-&gt;addRegister('remotes', 'registry.modDbRegister', array('directory' =&gt; 'remotes'));
    $modx-&gt;registry-&gt;remotes-&gt;connect();
    $modx-&gt;registry-&gt;remotes-&gt;subscribe('/distrib/instances/');
    $instances = $modx-&gt;registry-&gt;remotes-&gt;read(array('poll_limit' =&gt; 1, 'msg_limit' =&gt; 25, 'remove_read' =&gt; false));
    if (!empty($instances)) {
        foreach ($instances as $instance) {
            if ($instance == $_SERVER['SERVER_ADDR']) continue;
            $modx-&gt;registry-&gt;remotes-&gt;subscribe("/distrib/commands/{$instance}/");
            $modx-&gt;registry-&gt;remotes-&gt;send("/distrib/commands/{$instance}/", 'clearCache', array('expires' =&gt; time() + 1440));
        }
    }
}
</pre>
<p>
Other remote commands could also be sent and processed in this way. You would simply implement handling for additional commands in the switch statement in the RemoteCommands plugin.
</p>