<p>
By caching data that is being reused, a lot of database requests can be prevented, resulting in a better performance. MODX Revolution offers a number of different caching features on different levels within the application. The caching within MODX is mostly handled by the modCacheManager core class, which extends the xPDOCacheManager class and allows partition-specific cache handlers. The default implementation writes caches to files in the core/cache/ folder.
</p>

<p>
If you have a custom MODX_CONFIG_KEY defined, the cache manager will write to core/cache/MODX_CONFIG_KEY/ instead.
</p>

<h2>
General Caching Terminology &amp; Behavior
</h2>

<p>
MODX uses different <strong>partitions</strong> for separate types of data being cached. A partition is, simplified, a folder in the core/cache/ folder, but the real value of partitions is that each partition can be assigned different cache handlers. <strong>Cache handlers</strong> are derivatives of the xPDOCache class and provide a unified API for storing, reading and removing cache entries.
</p>

<p>
The default <strong>cache handler,</strong> xPDOFileCache, writes the cache to the file system in the core/cache/ folder, but other cache handlers are available in the core for APC (xPDOAPCCache), memcache(d) (xPDOMemCache, xPDOMemCached) and WinCache (xPDOWinCache).
</p>

<h2>
MODX Core Cache Partitions
</h2>

<p>
There are a number of partitions in the core. These can easily be identified by looking in the core/cache/ folder with the default cache configuration.
</p>

<p>
Typically you do not want work with the cached data directly (use the available APIs instead), but for means of understanding the MODX core we go through the core partitions here and briefly describe their purpose and contents.
</p>

<p>
As we’ll discuss later, it is also possible for custom providers to be used in custom development work.
</p>

<ul>
<li>
<strong>action_map</strong> Contains a big array of all the actions (IDs referencing controllers and namespaces) that can be accessed in the manager. As actions are deprecated and no longer used in 2.3, never rely on this.
</li>

<li>
<strong>auto_publish</strong> Contains a unix timestamp with the next time a resource needs to be automatically published or unpublished. (See modCacheManager.autoPublish())
</li>

<li>
<strong>context_settings</strong> For each context in the website, this contains a resource map (parent and child IDs), alias map, plugins used in the context and access policies.
</li>

<li>
<strong>db</strong> The db cache partition is used when the cache_db system or context setting is enabled and contains raw result sets for xPDO getObject/getCollection requests. More about this below.
</li>

<li>
<strong>includes</strong> This is not an actual cache partition, but contains PHP files where snippets and plugins are wrapped in function calls for easy execution by the core. See scripts for the cache partition for snippets and plugins.
</li>

<li>
<strong>logs</strong> Again, not an actual cache partition, but contains an error.log file and at times other log files (e.g. setup).
</li>

<li>
<strong>menu</strong> Contains, per manager language, a multi dimensional array of the manager top menu.
</li>

<li>
<strong>mgr</strong> Not an actual cache partition but is used by Smarty and the Google Minify in 2.2 to write cache files to.
</li>

<li>
<strong>registry</strong> Default location for the modRegistry to write file-based register logs to. Not an actual cache partition.
</li>

<li>
<strong>resource</strong> Contains, organised per context and resource ID, the partial-page caching mechanism for resources. These cache files contain the meta data for the resource, a cached representation of the resource (_content) with uncached tags left intact, access policies for the resource and elements and their sources used in processing the resource.
</li>

<li>
<strong>rss</strong> Not an actual cache partition, but used by MagpieRSS (powering the RSS dashboard widgets) to write its cache to.
</li>

<li>
<strong>scripts</strong> Contains the source for snippets and plugins, which are later written to the includes cache folder for inclusion.
</li>

<li>
<strong>setup</strong> Not an actual cache partition. Used by the MODX setup to cache smarty templates.
</li>

<li>
<strong>system_settings</strong> Contains the global MODX configuration and system settings. This partition is loaded first by requests to MODX. As alternative cache handlers for partitions are stored in the system settings, this partition can not be loaded from another cache handler that way.
</li>
</ul>

<p>
To change the cache handler for a specific cache partition, simply create a new system (or context) setting with the name of cache_PARTITION_handler (for example cache_resource_handler or cache_scripts_handler) and give it the value of the cache handler you would like to use. The default is xPDOFileCache but others are available for APC, memcache(d) and wincache.
</p>

<p>
Note that in MODX 2.0.x the cache system was quite different. The available partitions were different and the system settings were stored in core/cache/config.cache.php. If you are still running MODX 2.0.x now, you should spend more time upgrading and less time reading this document.
</p>

<h3>
Database caching
</h3>

<p>
If you enable the <strong>cache_db</strong> system setting, MODX can automatically cache database result sets fetched by any xPDOCriteria or xPDOQuery instance. This includes all of the result sets representing xPDOObjects or collections of xPDOObjects returned by methods like getObject and getCollection.
</p>

<p>
This feature can be enabled in environments where database access is more expensive than PHP include time, for instance, when using an external database server, or custom configured for environments with memcached, APC, or other caching systems available. This is a separate partition from the other cache partitions in MODX, so it can be configured with other cache handlers. See <a href="display/xPDO20/Caching">xPDO Caching</a> for additional information.
</p>

<h2>
Refreshing the MODX Core Cache
</h2>

<p>
To refresh any of the core MODX cache partitions, use the <code>modCacheManager-&gt;refresh()</code> method. The minimum call has no parameters and will refresh all core cache partitions.
</p>

<pre class="brush: php">
$modx-&gt;cacheManager-&gt;refresh();
</pre>
<p>
Alternatively, you can define a <code>$providers</code> array with partition <code>key =&gt; $partitionOptions</code> elements.
</p>

<pre class="brush: php">
// refresh the web and web2 context_settings only
$modx-&gt;cacheManager-&gt;refresh(array(
  'context_settings' =&gt; array('contexts' =&gt; array('web', 'web2')
));
</pre>
<p>
The second parameter, <code>$results</code>, is passed by reference and will contain the results of each of the cache partitions. Depending on the partition, this can be a boolean or an array with more information from the result of refreshing the specific partition. The function itself returns a boolean indicating if any of the partitions returned a boolean false.
</p>

<h2>
Programmatic (Custom) Caching
</h2>

<p>
By interacting with the modCacheManager, you can easily cache any type of data. There are several useful features for you to use in maintaining a valid cache. By using the modCacheManager with a custom partition (though not required), users of your code can change the cache handler and store the data in a memcached, APC or WinCache instance instead of the default file based cache.
</p>

<p>
The modCacheManager (xPDOCacheManager derivative) provides the following useful methods:
</p>

<ul>
<li>
<code>add($key, $var, $lifetime = 0, $options = array())</code>. Used for adding a value to the cache, but only if it does not yet exist or has expired.
</li>

<li>
<code>replace ($key, $var, $lifetime = 0, $options = array())</code>. Used for replacing an existing cached value with a different one.
</li>

<li>
<code>set ($key, $var, $lifetime = 0, $options = array())</code>. Used for setting a value in the cache no matter if it exists already (gets overwritten) or not (gets added).
</li>

<li>
<code>delete ($key, $options = array())</code>. Deletes a cached value from the cache.
</li>

<li>
<code>get ($key, $options = array())</code>. Gets a cached value from the cache.
</li>

<li>
<code>clean ($options = array())</code>. Flushes (empties) an entire cache provider. Make sure to define the xPDO::OPT_CACHE_KEY in the options array.
</li>
</ul>

<p>
In general you can use <code>get($key)</code> and <code>set($key, $value)</code> to retrieve and set values respectively, but the additional methods provide additional control over the way data is manipulated.
</p>

<p>
The <code>$options</code> array can contain the following options indicating the cache partition to write to, the cache handler to use and the default expiry time.
</p>

<ul>
<li>
<code>xPDO::OPT_CACHE_KEY</code>: the cache partition to write to.
</li>

<li>
<code>xPDO::OPT_CACHE_HANDLER</code>: the cache handler to use. Typically you shouldn’t hardcode this and instead let the specific implementation handle the cache handler via system settings (ie cache_PARTITION_handler system setting).
</li>

<li>
<code>xPDO::OPT_CACHE_EXPIRES:</code> the default expiry time.
</li>
</ul>

<h3>
Example 1: Simple Setting &amp; Getting
</h3>

<pre class="brush: php">
$str = 'My test cached data.';
// Writes the data to the default cache partition with an expiry time of 2 hours.
$modx-&gt;cacheManager-&gt;set('testdata', $str, 7200);
// Gets the data from cache again. Returns null if cache is not available or expired.
$str = $modx-&gt;cacheManager-&gt;get('testdata');
</pre>
<h3>
Example 2: Setting &amp; Getting to a custom partition
</h3>

<pre class="brush: php">
$str = 'My test cached data.';
$options = array(
  xPDO::OPT_CACHE_KEY =&gt; 'mypartition',
);
Writes the data to the default cache partition with an expiry time of 2 hours.
$modx-&gt;cacheManager-&gt;set('testdata', $str, 7200, $options);
// Gets the data from cache again. Returns null if cache is not available or expired.
$str = $modx-&gt;cacheManager-&gt;get('testdata', $options);
</pre>
<h2>
Note on Revolution 2.0
</h2>

<p>
MODX Revolution 2.0 had a different caching system with different partitions. To clear the cache in 2.0, you would use the clearCache() method that has been deprecated since 2.1. It's better to upgrade to the latest version than to continue using 2.0.
</p>

<pre class="brush: php">
// clear all the usual stuff by default (all files with the extension .cache.php
// in the cachePath + all object caches)
$modx-&gt;cacheManager-&gt;clearCache();
// clear only cache files with extension .php or .log in the web/ custom/
// or logs/ paths; no objects are cleared
$paths = array('web/', 'custom/', 'logs/');
$options = array('objects' =&gt; null, 'extensions' =&gt; array('.php', '.log'));
$modx-&gt;cacheManager-&gt;clearCache($paths, $options);
// clear all cache files with extension .php in the cachePath
// + all objects + execute the timed publishing checks
$paths = array('');
$options = array('objects' =&gt; '*', 'publishing' =&gt; true, 'extensions' =&gt; array('.php'));
$modx-&gt;cacheManager-&gt;clearCache($paths, $options);
</pre>