<p>
PHx (Placeholders Xtended) will add the capability of output modifiers when using placeholders, content tags (including template variables) and settings tags. The recursive parser allows for nested tags. Custom modifiers can be added by creating "mini-snippets" in the MODx resource manager.&nbsp; PHx is only intended for use with MODX Evolution, if you are using MODX Revolution see <a href="display/revolution20/Input+and+Output+Filters+%28Output+Modifiers%29" title="Input and Output Filters (Output Modifiers)">Output Filters</a>.
</p>

<h2>
<a name="PHx-Download" id="PHx-Download"></a>Download
</h2>

<p>
You can download the <a href="http://modx.com/extras/package/phx" class="external-link" rel="nofollow">latest version</a> of PHx from MODX extras site. The current version is <b>2.1.4-GA</b>.
</p>

<h2>
<a name="PHx-Installation" id="PHx-Installation"></a>Installation
</h2>

<h3>
<a name="PHx-Newinstall" id="PHx-Newinstall"></a>New install
</h3>

<ol>
<li>Download and extract the archive.
</li>

<li>Create a directory called "phx" in your [MODX Directory]/assets/plugins directory
</li>

<li>FTP or copy the files into [MODX Directory]/assets/plugins/phx
</li>

<li>Create a new plugin in the manager called "PHx" and copy/paste the contents of phx.plugin.txt into the code field.
</li>

<li>Check "OnParseDocument" at the System Events tab
</li>
</ol>

<h3>
<a name="PHx-Update" id="PHx-Update"></a>Update
</h3>

<ol>
<li>Download and extract the archive.
</li>

<li>Backup and delete the contents of [MODX Directory]/assets/snippets/phx
</li>

<li>Create a directory called "phx" in your [MODX Directory]/assets/plugins directory
</li>

<li>FTP or copy the files into [MODX Directory]/assets/plugins/phx
</li>

<li>Update the "PHx" plugin in the manager and copy/paste the contents of phx.plugin.txt into the code field.
</li>

<li>Check "OnParseDocument" at the System Events tab
</li>
</ol>

<h3>
<a name="PHx-Configuration" id="PHx-Configuration"></a>Configuration
</h3>

<p>
On the Configuration tab -&gt; Plugin configuration enter:&amp;phxdebug=Log events;int;0 &amp;phxmaxpass=Max. Passes;int;50
</p>

<h4>
<a name="PHx-AdvancedUsers" id="PHx-AdvancedUsers"></a>Advanced Users
</h4>

<p>
You can change the default values of the PHx parser
</p>

<ul>
<li>
<b>Log Events</b> 0 = Disabled 1 = Enabled logging of PHx When enabled PHx creates a detailed processing log for every page load in the MODX System Event log ( Manager-&gt;Reports-&gt;System Events)
</li>

<li>
<b>Max. Passes</b> Enter a number which represents the maximum depth of your nested tags. I recommend leaving this on the default value of 50.
</li>
</ul>

<h2>
<a name="PHx-Description" id="PHx-Description"></a>Description
</h2>

<p>
PHx (Placeholders Xtended) extends the use of placeholders, content tags (including template variables) and settings tags so you can easily format how the final output should look. When enabled it plugs into the MODX parser, extending it with modifiers, conditionals and as a bonus makes it truly recursive. PHx will also eliminate the need for lesser parameter snippets where you'd use them to format a value for display.
</p>

<p>
Great for templating!
</p>

<p>
Transforming a value is is as easy as adding <b>:modifier</b>.
</p>

<h3>
<a name="PHx-Supportedtags" id="PHx-Supportedtags"></a>Supported tags
</h3>

<p>
When enabled, PHx supports extensions of the following MODX tags:
</p>

<pre class="brush: php">
    [*createdby*]

    
</pre>
<p>
Some modifiers take options like:
</p>

<pre class="brush: php">
    somevar:esc:nl2br:strip

    
</pre>
<h4>
<a name="PHx-Advancedusage" id="PHx-Advancedusage"></a>Advanced usage
</h4>

<p>
There is a special placeholder called 'phx' which acts as a dummy placeholder to start a sequence without an actual variable.
</p>

<pre class="brush: php">
    [+phx:userinfo=`username`+]

    
</pre>
<h4>
<a name="PHx-Knownissues" id="PHx-Knownissues"></a>Known issues
</h4>

<h5>
<a name="PHx-Syntax" id="PHx-Syntax"></a>Syntax
</h5>

<p>
It seems logical, but I mention this as an issue because it's easy to take into account. Try to avoid the following character combinations in your template if they are not part of a MODx tag:
</p>

<pre class="brush: php">
    array[counter++]

    
</pre>
<p>
... might trigger weird behavior because of the +]. Also, using a closing CDATA tag like this:
</p>

<pre class="brush: php">
    [+string:lcase+]

    
</pre>
<ul>
<li>Input: This is a string
</li>

<li>Returns: this is a string
</li>
</ul>

<h4>
<a name="PHx-ucase" id="PHx-ucase"></a>ucase
</h4>

<p>
Returns current value with all alphabetic characters converted to uppercase.Example:
</p>

<pre class="brush: php">
    [+string:ucfirst+]

    
</pre>
<ul>
<li>Input:this is a string
</li>

<li>Returns:This is a string
</li>
</ul>

<h4>
<a name="PHx-length%5Clen"></a>length | len
</h4>

<p>
Returns length of the current value.Example:
</p>

<pre class="brush: php">
    [+string:notags+]

    
</pre>
<ul>
<li>Input:this &lt;b&gt;is&lt;/b&gt; a &lt;i&gt;string&lt;/i&gt;
</li>

<li>Returns:this is a string
</li>
</ul>

<h4>
<a name="PHx-esc" id="PHx-esc"></a>esc
</h4>

<p>
Escapes html and the bracket characters.
</p>

<h4>
<a name="PHx-htmlent" id="PHx-htmlent"></a>htmlent
</h4>

<p>
Converts the input to html entities.
</p>

<h4>
<a name="PHx-nl2br" id="PHx-nl2br"></a>nl2br
</h4>

<p>
Converts new lines to breaks.Example:
</p>

<pre class="brush: php">
    [+string:strip+]

    
</pre>
<ul>
<li>Input:this is a string
</li>
</ul>

<ul>
<li>Returns:this is a string
</li>
</ul>

<h4>
<a name="PHx-Other" id="PHx-Other"></a>Other
</h4>

<ul>
<li>
<b>reverse</b> Reverses the current value.
</li>

<li>
<b>wordwrap</b>(=`length`) length - charactersBreaks words in the current value longer than the given length of characters by putting a space in between.Default: 70 characters.
</li>

<li>
<b>limit</b>(=`length`) Returns the first X characters from the current value. Default: 100 characters.
</li>
</ul>

<h3>
<a name="PHx-Special" id="PHx-Special"></a>Special
</h3>

<h4>
<a name="PHx-date%28%3D%60dateformat%60%29"></a>date(=`dateformat`)
</h4>

<ul>
<li>dateformat: Like PHP <a href="http://www.php.net/strftime" class="external-link" rel="nofollow">strftime</a>
</li>

<li>Converts unix timestamps to the format specified.
</li>
</ul>

<p>
Example:
</p>

<pre class="brush: php">
    [+placeholder:select=`0=OFF&amp;1=ON&amp;2=UNKNOWN`+]

    
</pre>
<ul>
<li>Returns ON
</li>
</ul>

<h3>
<a name="PHx-Conditionaloperators" id="PHx-Conditionaloperators"></a>Conditional operators
</h3>

<h4>
<a name="PHx-is" id="PHx-is"></a>is
</h4>

<ul>
<li>alias: eq
</li>
</ul>

<p>
is equal to (==)
</p>

<h4>
<a name="PHx-ne" id="PHx-ne"></a>ne
</h4>

<ul>
<li>alias: isnot, isnt
</li>
</ul>

<p>
is not equal to (!=)
</p>

<h4>
<a name="PHx-eg" id="PHx-eg"></a>eg
</h4>

<ul>
<li>alias: isgt
</li>
</ul>

<p>
is equal or greater than (&gt;=)
</p>

<h4>
<a name="PHx-el" id="PHx-el"></a>el
</h4>

<ul>
<li>alias: islt
</li>
</ul>

<p>
is equal or lower than (&lt;=)
</p>

<h4>
<a name="PHx-gt" id="PHx-gt"></a>gt
</h4>

<p>
is greater than (&gt;)
</p>

<h4>
<a name="PHx-lt" id="PHx-lt"></a>lt
</h4>

<p>
is lower than (&lt;)
</p>

<h4>
<a name="PHx-mo%3D%60Webgroups%60"></a>mo=`Webgroups`
</h4>

<ul>
<li>aliases: isinrole, ir, memberof
</li>
</ul>

<p>
Takes a comma-separated list of webgroup names and returns true/false depending on the user being in the group or not (replaces the "inrole" modifier which had to be combined with a conditional operator). Example:
</p>

<pre class="brush: php">
    [+phx:if=`[*id*]`:is=`2`:or:is=`3`:then=`{{Chunk}}`:else=`{{OtherChunk}}`+]

    
</pre>
<h4>
<a name="PHx-and" id="PHx-and"></a>and
</h4>

<p>
Previous AND next statement
</p>

<pre class="brush: php">
    [+myplaceholder:len:gt=`3`:show+]

    
</pre>
<ul>
<li>Will return the value of myplaceholder if it contains more then 3 characters.
</li>
</ul>

<h4>
<a name="PHx-Moreexamples" id="PHx-Moreexamples"></a>More examples
</h4>

<h5>
<a name="PHx-Example1" id="PHx-Example1"></a>Example 1
</h5>

<p>
<b>myplaceholder</b> is set to <b>myvalue</b>
</p>

<ul>
<li>
<b>[</b><b>+myplaceholder:is=`myvalue`:then=`Correct`:else=`Incorrect`+</b><b>]</b> will return:Correct
</li>

<li>
<b>[</b><b>+myplaceholder:isnot=`myvalue`:then=`Correct`:else=`Incorrect`+</b><b>]</b>
</li>

<li>
<b>[</b><b>+myplaceholder:is=`othervalue`:then=`Correct`:else=`Incorrect`</b><b>+]</b> will both return:Incorrect
</li>
</ul>

<h5>
<a name="PHx-Example2" id="PHx-Example2"></a>Example 2
</h5>

<ul>
<li>
<b>myplaceholder</b> is set to <b>2</b>
</li>

<li>
<b>someplaceholder</b> is set to <b>3</b>
</li>

<li>
<b>otherplaceholder</b> is set to <b>1</b>
</li>
</ul>

<pre class="brush: php">
    [+myplaceholder:mymodifier+]

    
</pre>
<ul>
<li>
<b>$output</b> contains the value "<b>test</b>".
</li>

<li>
<b>$options</b> contains <b>nothing</b> because they aren't specified.
</li>
</ul>

<pre class="brush: php">
    &lt;?php
$defaultValue = " because I do love MODx";
if (strlen($options)&gt;0) {
$newvalue = $output . $options;
} else {
$newvalue = $output . $defaultValue;
}
return $newvalue;
?&gt;

    
</pre>
<ol>
<li>Click "Save" and your custom modifier (<b>:love2</b>) is ready for use!
</li>
</ol>

<h3>
<a name="PHx-Contributed" id="PHx-Contributed"></a>Contributed
</h3>

<p>
Check <a href="display/ADDON/PHx+Custom+Modifiers" title="PHx Custom Modifiers">PHx/CustomModifiers</a> for a list of custom modifiers you can install.
</p>

<h2>
<a name="PHx-TipsandTricks" id="PHx-TipsandTricks"></a>Tips and Tricks
</h2>

<h3>
<a name="PHx-UsingPHxinnonphxsnippettemplates" id="PHx-UsingPHxinnonphxsnippettemplates"></a>Using PHx in non-phx snippet templates
</h3>

<p>
Most snippets render their templates "locally" before they are passed to MODx. Unless the snippet's description states it's using PHx to render the templates it's not possible to use the modifiers directly, however you still CAN use PHx by using a special modifier called phx:input.
</p>

<p>
This example will <b>not</b> work with a non-PHx snippet:
</p>

<pre class="brush: php">
    [+phx:input=`[+myplaceholder+]`:modifier1:modifier2+]

    
</pre>
<p>
Or:
</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">
[+phx:input=`[+myplaceholder+]`:modifier1:modifier2+]
</pre>
</div>
</div>

<p>
This example will work with a non-PHx snippet. Some restrictions may apply depending on the snippet logic.
</p>

<h2>
<a name="PHx-TechnicalDocumentation" id="PHx-TechnicalDocumentation"></a>Technical Documentation
</h2>

<p>
This part of the documentation is not intended for the average user but is just here to give some background information of how PHx works.
</p>

<p>
PHx makes use of the <b>OnParseDocument</b> (MODx API) event to process the documentOutput. OnParseDocument is triggered before the default MODx elements are processed so PHx is activated on the raw template version of the output and goes trough the following phases:
</p>

<ol>
<li>We only start if we did not reach maximum passes yet.
</li>

<li>A hash is made of the current content of the document to check for changes in the process later on.
</li>

<li>The document is prepared with some filters to escape the rogue bracket characters (the ones that are not part of a MODx tag).
</li>

<li>The document now enters the main parser function:
<ol>
<li>A hash is made of the current content of the document to check for changes in the process later on.
</li>

<li>Chunks are merged using <b>mergeChunkContent</b> (MODx API).
</li>

<li>Snippets are detected using an advanced regular expression that takes nested tags into account:
<ol>
<li>Snippet calls which contain no nested tags are matched.
</li>

<li>Each matching call is checked for (non-)cached output, prepared and passed to <b>evalSnippets</b> (MODx API).
</li>
</ol>
</li>

<li>Snippet output is merged with the document.
</li>

<li>The rest of the MODx tags are detected using an advanced regular expression that takes nested tags into account:
<ol>
<li>Document/Template Variable output is gathered from <b>mergeDocumentContent</b> (MODx API).
</li>

<li>Setting Variables output is gathered from <b>mergeSettingsContent</b> (MODx API).
</li>

<li>Placeholder output is gathered in the following order PHx, MODx.
</li>

<li>If the requested placeholder is not set it is skipped for the current pass (replaced with original).
</li>
</ol>
</li>

<li>For each detected tag, the ones which also contains modifiers are passed to the filter that will modify the value as given.
</li>

<li>The final output for all tags is then merged into the document.
</li>

<li>A hash is made of the content of the merged document and compared to the initial hash to check if there were changes.
</li>

<li>If we did not reach maximum passes AND if the document content has changed we repeat this entire level (pass+1).
</li>
</ol>
</li>

<li>The document's rogue bracket characters are restored to their non-escaped versions.
</li>

<li>The tags that are still present (and thus unresolved for the entire document) are removed from the output.
</li>

<li>A hash is made of the new document content and compared to the initial hash to check if there were changes.
</li>

<li>If the document content has changed let it repeat this entire level.
</li>

<li>Log the parser steps into the Event Log if required.
</li>

<li>Return the new documentOutput to MODx.
</li>
</ol>

<p>
After the entire PHx logic is through, it's 99% certain that MODx does not have any tags left to parse. You could say that PHx replaces the core function of MODx that handles the merging (with added flexibility by allowing nesting). However, the different types of elements are still processed by the responsible MODx functions.
</p>

<h2>
<a name="PHx-Troubleshooting" id="PHx-Troubleshooting"></a>Troubleshooting
</h2>

<p>
If you experience problems with the page loading slowly, this could be cause by a PHx loop.&nbsp; Lower the Max Passes value to 5 or 10, this should allow the affected page to finish loading thus showing the error.
</p>

<p>
Example of a PHx Loop:Page Call: [<ins>+phx:if=`</ins><ins><span class="error">[*shownews*]</span></ins><ins>`:is=`1`:then=`</ins><tt><ins>Chunk</ins></tt><ins>`</ins>+]
<br />
Chunk Contents: ?[<ins>+phx:if=`</ins><ins><span class="error">[*shownews*]</span></ins><ins>`:is=`1`:then=`</ins><tt><ins>Chunk</ins></tt><ins>`</ins>+]
</p>